# Порівняння ефективності жадібного алгоритму та динамічного програмування

## Жадібний алгоритм (`find_coins_greedy`)
- **Часова складність:** O(N), де N — кількість різних номіналів монет.
- **Продуктивність:** Дуже швидкий навіть для великих сум, оскільки для кожного номіналу монети виконується лише одна операція ділення.
- **Особливості:** Не завжди гарантує мінімальну кількість монет для довільних наборів номіналів, але для стандартних європейських/українських номіналів працює оптимально.

## Динамічне програмування (`find_min_coins`)
- **Часова складність:** O(N * S), де N — кількість номіналів, S — сума.
- **Продуктивність:** Для малих і середніх сум працює добре, але при дуже великих сумах (наприклад, S > 10^5) споживає більше памʼяті та часу, оскільки будує таблицю розміром S.
- **Особливості:** Завжди знаходить мінімальну кількість монет для будь-якого набору номіналів.

## Висновки
- Для стандартних номіналів і великих сум жадібний алгоритм значно швидший і менш ресурсоємний.
- Динамічне програмування доцільно використовувати, якщо набір номіналів нестандартний і жадібний підхід не гарантує оптимальності.
- Для дуже великих сум рекомендується використовувати жадібний алгоритм через його лінійну складність.

---

